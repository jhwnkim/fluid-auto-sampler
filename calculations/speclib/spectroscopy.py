import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import cvxopt

from scipy.interpolate import BSpline, splev, splrep
from scipy.ndimage.filters import median_filter
from scipy.signal import savgol_filter

# plt.rc('text', usetex=True)
# plt.rc('font', family='serif')
np.set_printoptions(precision=5, suppress=True, linewidth=180)

############################################################## smoothing th
def load_txt_new(file_name, sg_win_len=31, sg_poly_order=3, if_plot=True):
    df = pd.read_table(file_name + '.txt')
    wave = df.iloc[0, 2:-1].values
    X_raw = df.iloc[2:, 2:-1].values
    X = spectrum_average(X_raw[:30, :], sg_win_len=sg_win_len, sg_poly_order=sg_poly_order)
    if if_plot:
        fig, ax = plt.subplots()
        ax.plot(X_raw.T)
        plt.show()

    return X, wave

##############################################################
def load_txt_auto(file_name, sg_win_len=31, sg_poly_order=3, if_plot=True):
    """
    Load txt files generated by ASCII out put file function in experiment setup read_table
    delimiter :  comma
    line termination characters : line feed, carriage return
    Parameters:
    - file_name: string (filename without extension)
    - sg_win_len: integer (length of filter window)
    - sg_poly_order: integer (filter order)
    returns:
    - X: (N,) array (spectra intensity)
    - wave: (N,) array (wavelengths in nm)
    """
    df = pd.read_csv(file_name + '.txt', sep=',', header=None)

    wave = df.loc[df[0] == 1][1]
    X = df[2].values
    X_raw = X.reshape(X.shape[0]//wave.shape[0], wave.shape[0])
    X = spectrum_average(X_raw[:30, :], sg_win_len=sg_win_len, sg_poly_order=sg_poly_order)
    if if_plot:
        fig, ax = plt.subplots()
        ax.plot(X_raw.T)
        plt.show()

    return X, wave

##############################################################
def load_txt_auto_multi(file_name, sg_win_len=31, sg_poly_order=3, acq_per_sample=10, if_plot=True):
    """
    Load txt files generated by ASCII out put file function in experiment setup read_table
    delimiter :  comma
    line termination characters : line feed, carriage return
    Used when multiple samples are in one txt file
    Parameters:
    - file_name: string (filename without extension)
    - sg_win_len: integer (length of filter window)
    - sg_poly_order: integer (filter order)
    - acq_per_sample: integer (number of acquisitions per sample to break up spectra)
    returns:
    - X: (number of samples, pixel) sized array (spectra intensities)
    - wave: (number of samples, pixel) sized array (wavelengths in nm)
    """
    df = pd.read_csv(file_name + '.txt', sep=',', header=None)

    wave = df.loc[df[0] == 1][1]
    X = df[2].values
    X_raw = X.reshape(X.shape[0]//wave.shape[0]//acq_per_sample, acq_per_sample, wave.shape[0])

    X = np.zeros((X.shape[0]//wave.shape[0]//acq_per_sample, wave.shape[0]))
    for i in range(X_raw.shape[0]):
        X[i,:] = spectrum_average(X_raw[i, :30, :], sg_win_len=sg_win_len, sg_poly_order=sg_poly_order)
    if if_plot:
        fig, ax = plt.subplots()
        ax.plot(X_raw.reshape(X_raw.shape[0]*X_raw.shape[1], X_raw.shape[2]).T)
        plt.show()

    return X, wave

##############################################################
def load_and_smooth(file_name, file_no=0, sg_win_len=31, sg_poly_order=3, if_plot=True):
    X_raw, wave = load_sequential_txt(file_name, file_no)
    X = spectrum_average(X_raw, sg_win_len=sg_win_len, sg_poly_order=sg_poly_order)
    if if_plot:
        fig, ax = plt.subplots()
        ax.plot(X)
        plt.show()
    return X, wave

##############################################################
def load_txt_and_plot(file_name, file_no=0, if_plot=True):
    if file_no == 0:
        x, wave = load_single_txt(file_name)
    else:
        X, wave = load_sequential_txt(file_name, file_no)
        x = spectrum_average(X)
    if if_plot:
        fig, ax = plt.subplots()
        ax.plot(x)
        plt.show()
    return x, wave

##############################################################
def load_single_txt(file_name):
    file_name_txt = file_name + '.txt'
    df = pd.read_table(file_name_txt, header=None, delimiter='\t| ', engine='python')

    wave = np.asarray(df[0])
    x = np.asarray(df[2])
    return x, wave

##############################################################
def load_sequential_txt(file_name, file_no):
    X = []

    for i in range(file_no):
        x, wave = load_single_txt(file_name + str(i + 1))
        X.append(x)

    X = np.asarray(X)
    return X, wave

######################################################################
def wave_2_waveshift(wave, laser):
    wave_shift = 1 / laser * 1e7 - 1 / wave * 1e7
    return wave_shift

######################################################################
def spectrum_average(X, sg_win_len=31, sg_poly_order=3):
    X = np.median(X, axis=0)
    # X = savgol_filter(X, window_length=sg_win_len, polyorder=sg_poly_order, mode='nearest')
    X = savgol_filter(X, window_length=sg_win_len, polyorder=sg_poly_order)
    return X

######################################################################
def background_remove_full(X, order, basis_type, method):
    X = np.atleast_2d(X)
    X_sig, X_bkg = np.atleast_2d(X).copy(), np.atleast_2d(X).copy()

    if basis_type == 'poly':
        basis = get_poly_basis(X_sig[0, :], order)
    elif basis_type == 'BS':
        basis = get_BS_basis(X_sig[0, :], order)
    else:
        print('Error!')

    for i in range(X.shape[0]):
        if method == 'Lieber':
            X_sig[i, :], X_bkg[i, :] = Lieber_fit_with_basis(X[i, :], basis)
        elif method == 'QP':
            X_sig[i, :], X_bkg[i, :] = QP_fit(X[i, :], basis)
        else:
            print('Error!')

    return X_sig, X_bkg

######################################################################
def plot_background_and_signal(X, order, basis_type, method):
    X_sig, X_bkg = background_remove_full(X, order, basis_type, method)

    fig, ax = plt.subplots()
    ax.plot(X.T)
    ax.plot(X_bkg.T)
    plt.show()

######################################################################
def Lieber_fit_with_basis(x, basis):
    x_iter = x.copy()
    iter_no = 300

    for iii in range(0, iter_no):
        coeffs = np.linalg.lstsq(basis, x_iter, rcond=None)[0]
        x_bkg = basis @ coeffs
        x_iter = np.fmin(x_bkg, x_iter)

    coeffs = np.linalg.lstsq(basis, x_iter, rcond=None)[0]
    x_bkg = basis @ coeffs
    x_sig = x - x_bkg
    return x_sig, x_bkg

######################################################################
def QP_fit(y, A, margin=0, if_plot=False):
    P = A.T @ A
    q = -y.T @ A
    G = A
    h = y - margin

    P = cvxopt.matrix(P, tc='d')
    q = cvxopt.matrix(q, tc='d')
    G = cvxopt.matrix(G, tc='d')
    h = cvxopt.matrix(h, tc='d')

    cvxopt.solvers.options['show_progress'] = False
    sol = cvxopt.solvers.qp(P, q, G, h)
    x = np.array(sol['x']).flatten()

    if if_plot:
        fig, ax = plt.subplots()
        ax.plot(y)
        ax.plot(A @ x)
        plt.show()

    y_bkg = A @ x
    y_sig = y - y_bkg

    return y_sig, y_bkg

######################################################################
def get_BS_basis(x, BS_coeff_no):
    N = len(x)
    l = np.arange(N)

    BS_k_order = 3
    BS_knot_no = BS_coeff_no + BS_k_order + 1
    BS_t = np.linspace(0, N - 1, BS_knot_no)

    BS_c_unit = np.ones(BS_coeff_no)
    BS_unit_original = splev(l, BSpline(BS_t, BS_c_unit, BS_k_order).tck)
    BS_basis = np.zeros((N, BS_coeff_no))

    for iii in range(BS_coeff_no):
        BS_c_perm = np.zeros(BS_coeff_no)
        BS_c_perm[iii] += 1
        BS_unit_perm = splev(l, BSpline(BS_t, BS_c_unit + BS_c_perm, BS_k_order).tck)
        BS_basis[:, iii] = BS_unit_perm - BS_unit_original

    return BS_basis

######################################################################
def get_poly_basis(x, poly_coeff_no):
    N = len(x)
    l = np.arange(N)

    poly_basis = np.zeros((N, poly_coeff_no))

    for iii in range(poly_coeff_no):
        poly_basis[:, iii] = l**iii
        poly_basis[:, iii] /= np.linalg.norm(poly_basis[:, iii])

    return poly_basis
